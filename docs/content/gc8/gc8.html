<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

  <link rel="stylesheet" type="text/css" href="../../style.css">
  <script type="text/javascript" src="../../script.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>

  <!-- and it's easy to individually load additional languages -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/cpp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/llvm.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/makefile.min.js"></script>

  <script>
    hljs.highlightAll();
    hljs.initLineNumbersOnLoad();
  </script>




  <title>Garbage Collection (Sec.8)</title>
  <meta name="keywords" content="GC"/>
  <meta name="date" content="2022-07-29"/>

  <style type="text/css">
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" />
</head>
<body>
<a href="../../index.html">トップへ</a>
<p>
  <date>2022-07-29</date>
      <tag><a href="../../tag.html?tag=GC">GC</a></tag>
  </p>

<h1
id="incremental-and-concurrent-garbage-collection-gc-81---84">Incremental
and Concurrent Garbage Collection (GC 8.1 - 8.4)</h1>
<div class="box">
<p><strong>本章の目的</strong> : 最悪ポーズ時間の削減．</p>
</div>
<p>この性質は interactive / real-time システムで重要．</p>
<p>本章は，parallel, concurrent, incremental な GC に着目．<br>
なお，sequential なマシンを仮定し，並列実行の難しい話は無視する．</p>
<h2 id="gcの種別">GCの種別</h2>
<h3 id="serial-parallel-concurrent">Serial, Parallel, Concurrent</h3>
<div class="flex46">
<div class="flex-left">
<p>GCは3種類に分けられる．(<a
href="https://gihyo.jp/dev/serial/01/jvm-arc/0004">参考</a>)</p>
<dl>
<dt>Serial :</dt>
<dd>
GC 中は mutator が止まる．
</dd>
<dt>Parallel (並列) :</dt>
<dd>
GC が複数スレッド走る．<br>その間 mutator は止まる．
</dd>
<dt>Concurrent (並行) :</dt>
<dd>
GC と mutator が<strong>並列</strong>に走る．
</dd>
</dl>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">3種のGC</figcaption><pre><code class="nohljsln txt">  ---&gt; : Mutator
  ===&gt; : GC

  Serial           Parallel         Concurrent
  ---&gt;|    |---&gt;   ---&gt;|===&gt;|---&gt;   ---&gt;
  ---&gt;|===&gt;|---&gt;   ---&gt;|===&gt;|---&gt;   ---&gt;
  ---&gt;|    |---&gt;   ---&gt;|===&gt;|---&gt;   ---&gt;
                                    ===&gt;</code></pre></figure>
</div>
</div>
<h3 id="その他の種別">その他の種別</h3>
<p>Serial, parallel, concurrent とは直行する分類．</p>
<h4 id="generational-gc-7章">Generational GC (7章)</h4>
<p>セルを世代に分け，若い世代を集中的に処理．</p>
<ul>
<li>目的 : 平均ポーズ時間の削減．</li>
<li>仮定 : 若い世代は短命．</li>
<li>欠点 : 最悪ポーズ時間が長い．
<ul>
<li>仮定が外れると major GC が大量に走る．</li>
</ul></li>
</ul>
<h4 id="incremental-gc-本章">Incremental GC (本章)</h4>
<p>Mark や sweep を少しずつする手法．</p>
<ul>
<li>目的 : 最悪ポーズ時間の削減．</li>
</ul>
<h2 id="いわゆる-real-time-gc-への批判">いわゆる real-time GC
への批判</h2>
<p>Real-time システムには２種類ある (by <a
href="https://ja.wikipedia.org/wiki/%E3%83%AA%E3%82%A2%E3%83%AB%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0">Wikipedia</a>):</p>
<ul>
<li><strong>Hard real-time</strong> システム
<ul>
<li>遅延よりも誤った応答のほうがマシなシステム．</li>
<li>→ 最悪ケースを抑えることが重要．</li>
<li>e.g エアバッグ</li>
</ul></li>
<li><strong>Soft real-time</strong> システム
<ul>
<li>遅延してでも答えを返すべきシステム．</li>
<li>→ 平均を抑えることが重要．</li>
<li>e.g ATM</li>
</ul></li>
</ul>
<p><strong>いわゆる real-time GC は最悪ケースを見ていない．</strong><br>
<strong>→ hard real-time なシステムで使えない．</strong><br></p>
<p>GC本筆者は，こうしたシステムを real-time
と呼ぶことが許せない様子．</p>
<h2 id="81-synchronization">8.1 Synchronization</h2>
<h3 id="復習-tricolor">(復習) Tricolor</h3>
<ul>
<li>黒 : 自身と全ての子に訪問済み．</li>
<li>灰 : 自身は訪問済み．未訪問の子あり．</li>
<li>白 : 未訪問 (最後まで白ならゴミ)．</li>
</ul>
<p>実装手段</p>
<ul>
<li>各セルに2bit割り当てる．</li>
<li>各セルに1bit割り当て，スタックを併用．
<ul>
<li>黒 : マークされ，かつ，スタックにない．</li>
<li>灰 : マークされ，かつ，スタックにある．</li>
<li>白 : マークされてない．</li>
</ul></li>
<li>Cheny のアルゴリズム (陽には色を塗らない)．</li>
</ul>
<hr />
<p>記法 :</p>
<ul>
<li>黒 : 黒色のセル (他の色も同様)．</li>
<li>黒→白 : 黒から白へのエッジ (他の色も同様)．</li>
</ul>
<h3 id="一貫性の問題">一貫性の問題</h3>
<p>GC と mutator
が同時に動くため，互いに与える影響を考える必要がある．</p>
<h4 id="gc-が-mutator-に与える影響">GC が Mutator に与える影響</h4>
<div class="box">
<dl>
<dt>守るべき一貫性 @ Mutator :</dt>
<dd>
<strong>セルのアドレスが勝手に変化しない．</strong>
</dd>
</dl>
</div>
<p>Copy GC等はこの一貫性に抵触するため，対処が必要．<br> この章では
Mark-Sweep を中心に扱うので，あまり考えなくて良い．</p>
<h4 id="mutator-が-gc-に与える影響">Mutator が GC に与える影響</h4>
<div class="flex64">
<div class="flex-left">
<div class="sticky">
<div class="box">
<dl>
<dt>守るべき一貫性 @ GC :</dt>
<dd>
<strong>任意の白は黒でない親を持つ．</strong>
</dd>
</dl>
</div>
<p>一貫性を破ると…</p>
<ul>
<li>その白は最後まで訪問されない．</li>
<li>→ 誤った解放が起こる．</li>
</ul>
<p>GC と mutator が並列に動く．<br> → <strong>Mutator が
一貫性を破らないよう注意．</strong></p>
<p>Mutator が一貫性を破る手順 :</p>
<ul>
<li>[1→2] 黒→白 を貼る．</li>
<li>[2→3] いま貼ったエッジを，白に入る唯一のエッジとする．</li>
</ul>
</div>
</div>
<div class="flex-right">
<p><img src="img/illegal.dio.svg"
alt="ユーザがポインタを張り替えた場合" /></p>
</div>
</div>
<h2 id="82-barrier-methods">8.2 Barrier methods</h2>
<p>「Mutator による一貫性の破壊」を防ぐ手段は2つある．</p>
<ul>
<li>黒→白 ができる前に白を訪問 (Read barrier を使う)．
<ul>
<li>Mutator に白を見せない．</li>
</ul></li>
<li>黒→白 を作った際に覚えておく (Write barrier を使う)．</li>
</ul>
<h3 id="手法1--mutator-に白を見せない-read-barrier">手法1 : Mutator
に白を見せない (read barrier)</h3>
<ul>
<li>Mutator が白にアクセスしようとした瞬間に GC
が割り込み，そこを訪問．</li>
<li>Read barrier を用いる．</li>
</ul>
<h4 id="実装法">実装法</h4>
<p><strong>ハードウェアの助けを借りる :</strong><br></p>
<ul>
<li>オーバーヘッドは無視できる程度．</li>
<li>大昔のハードウェア (e.g Symbolics, Explorer, SPUR) で可能．
<ul>
<li>今(’97年)のハードウェアはできない．</li>
</ul></li>
</ul>
<p><strong>ソフトウェア的にやる :</strong><br></p>
<ul>
<li>遅い．</li>
<li>インライン化も微妙．
<ul>
<li>Zorn の調査によれば，ポインタのロードはプログラム全体の
13-15%．</li>
<li>inline されるのが3命令でも，コードサイズは +40%．</li>
<li>命令バッファにも害がある．</li>
</ul></li>
</ul>
<p><strong>OS の助けを借りる (8.6節) :</strong><br></p>
<ul>
<li>OS のメモリプロテクションを使う (8.6節)．</li>
</ul>
<h3 id="手法2--黒白-を覚えておく-write-barrier">手法2 : 黒→白
を覚えておく (write barrier)</h3>
<p>Write barrier を使う．<br> Wilson は write-barrier を2種に分類した
:</p>
<dl>
<dt><em>Snapshot-at-the-beginning</em></dt>
<dd>
参照を消す際に，もともと参照されていたノードに訪問．
</dd>
<dt><em>Incremental-update</em></dt>
<dd>
参照を書き込む際に，そのエッジの親 or 子を訪問．
</dd>
</dl>
<p><img src="img/write-barrier.dio.svg" /></p>
<h3 id="保守の度合い">保守の度合い</h3>
<div class="flex64">
<div class="flex-left">
<p>ゴミは3つに分類できる．</p>
<ul>
<li>A : サイクル開始時にすでにゴミ．</li>
<li>B : サイクル開始時は生きていたが，サイクルの途中でゴミに．</li>
<li>C : サイクルの途中で作られ，サイクルの途中でゴミに．</li>
</ul>
</div>
<div class="flex-right">
<p><img src="img/lifetime.dio.svg" /></p>
</div>
</div>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Snapshot</th>
<th style="text-align: center;">Incremental (子を塗る)</th>
<th style="text-align: center;">Incremental (親を塗る)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">全回収</td>
<td style="text-align: center;">全回収</td>
<td style="text-align: center;">全回収</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">回収しない</td>
<td style="text-align: center;">部分的に回収<br>(回収率は実装依存)</td>
<td
style="text-align: center;">子を塗る場合より多く回収<br>(回収率は実装依存)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">(新規セルの扱いに依存)</td>
<td style="text-align: center;">(新規セルの扱いに依存)</td>
<td style="text-align: center;">(新規セルの扱いに依存)</td>
</tr>
</tbody>
</table>
<p>Q. なぜ親を塗るほうが回収率が良い？<br> A. 例えば次の例を考える :</p>

<figure><pre><code class="cpp">Node *p = malloc(sizeof(Node));
Node *c = malloc(sizeof(Node));
// この時点で: p: 黒, c: 白 と仮定．
p-&gt;child = c;
// この時点で
//   親を塗る場合: p: 灰, c: 白
//   子を塗る場合: p: 黒, c: 灰
p-&gt;child = nullptr;
c = nullptr;
// この時点で c はゴミ．
//   子を塗った場合，c は絶対に回収されない．
//   親を塗った場合，c は回収されるかもしれない．</code></pre></figure>
<hr />
<p>以降では write barrier を使う方法に着目する．</p>
<h2 id="83-mark-sweep-collectors">8.3 Mark-Sweep collectors</h2>
<p>Write barrier のよく知られた手法を比較していく．<br> (Read barrier
はコストが掛かるので，non-moving なコレクタにはめったに使われない．)</p>
<div id="compare-table">
<table>
<thead>
<tr class="header">
<th style="text-align: right;">手法</th>
<th style="text-align: left;">色の表現</th>
<th style="text-align: left;">Write-barrier の種別</th>
<th style="text-align: left;">新規セルの扱い</th>
<th style="text-align: left;">GCサイクルの初期化処理</th>
<th style="text-align: left;">GCサイクルの終了判定</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">Sequential algorithm<br>by Yuasa</td>
<td style="text-align: left;">Mark-bit + Stack</td>
<td style="text-align: left;">Snapshot</td>
<td style="text-align: left;">スイープ済みなら白．未スイープなら黒</td>
<td style="text-align: left;">レジスタ・スタックをコピー．</td>
<td style="text-align: left;">Mark-stack が空になったら</td>
</tr>
<tr class="even">
<td style="text-align: right;">On the Fly collector<br>by Dijkstra et
al.</td>
<td style="text-align: left;">各セルに2-bit</td>
<td style="text-align: left;">Incremental<br> (任意色 → 白
が貼られたら，子を灰に)</td>
<td style="text-align: left;">黒か灰</td>
<td style="text-align: left;">全 root を灰に</td>
<td style="text-align: left;">ヒープを走査して灰が無かったら</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Multi-processing, Compactifying
algorithm<br>by Steele</td>
<td style="text-align: left;">Mark-bit + Stack</td>
<td style="text-align: left;">Incremental<br>(黒 → 白
が貼られたら，親を灰に)</td>
<td style="text-align: left;">フェーズごとに細かく分岐</td>
<td style="text-align: left;">Root から辿れるセルをマーク</td>
<td style="text-align: left;">Mark-stack が空になったら</td>
</tr>
<tr class="even">
<td style="text-align: right;">Four-color method<br>by Kung and
Song</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">Incremental</td>
<td style="text-align: left;">Mark 中は灰，その他は白</td>
<td style="text-align: left;">全 root を Mark-queue へ</td>
<td style="text-align: left;">Mark-queue が空になったら</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>4章の手法で mark を改善することも可能．</li>
<li>ただし，Deutsch-Schorr-Waite の pointer-reversal method は使えない．
<ul>
<li>トレース中にノードが mutator からアクセス不能になるため．</li>
</ul></li>
</ul>
<h2 id="gc-の初期化処理">GC の初期化処理</h2>
<p>各手法を比較する前に，GC の初期化処理にまつわる課題を見ておく．</p>
<h3 id="初期化処理--gc-サイクルの開始時期">初期化処理 | GC
サイクルの開始時期</h3>
<p><strong>GC が mutator と並列に走る場合 :</strong></p>
<ul>
<li>前回のサイクルが終わったら即開始．</li>
</ul>
<p><strong>GC が mutator と平行に走る場合 :</strong></p>
<ul>
<li>メモリが不足した際に開始．</li>
<li>GC 中にメモリが枯渇してなならない．</li>
<li>空き容量がある閾値を割ったときにサイクルを始めるのが良い．
<ul>
<li>Yuasa 曰く，通常は閾値を 22% とすれば良い．</li>
</ul></li>
</ul>
<h4 id="閾値に関する考察--incremental">閾値に関する考察 @
Incremental</h4>
<p><code>alloc</code> 毎にグラフを <span
class="math inline">k</span>-word 分トレースすることを考える．</p>
<ul>
<li><span class="math inline">k</span> が小さいほど
ポーズ時間は<quiz>短く</quiz>，一時的なメモリリーク量は<quiz>多く</quiz>なる．</li>
<li>→ <span class="math inline">k</span>
はなるべく小さくしたいが，途中でメモリが枯渇してはならない．</li>
</ul>
<div class="flex64">
<div class="flex-left">
<p><u>Q. <span class="math inline">k</span>
はどこまで小さくできるか？</u></p>
<ul>
<li><span class="math inline">R</span>-word
ある領域のトレースを考える．</li>
<li>各 <code>alloc</code> では，<span class="math inline">1</span>-word
確保し，<span class="math inline">k</span>-word マークする．</li>
<li>ヒープ全体のサイズを <span class="math inline">M</span>-word
とする．</li>
</ul>
<p>このとき，</p>
<ul>
<li>トレースは最大 <span class="math inline">R/k</span> 回の
<code>alloc</code> で終わる．</li>
<li>その間に最大 <span class="math inline">R/k</span>-word
確保される．</li>
<li>よってトレース完了時のヒープ使用量は最大 <span class="math inline">R
+ R/k</span>-word</li>
<li>メモリが枯渇しないた条件 : <span class="math inline">R + R/k &lt;
M</span></li>
<li>→ <span class="math inline">k &gt; R/(M-R)</span>
でなくてはならない．</li>
</ul>
</div>
<div class="flex-right">
<div class="sticky">
<p><img src="img/trace-rate.dio.svg" /></p>
</div>
</div>
</div>
<h3 id="初期化処理--ルートの把握">初期化処理 | ルートの把握</h3>
<p><strong>最も簡単な方法</strong> :</p>
<ul>
<li>レジスタ，グローバル変数，スタック中のポインタ値を灰に．</li>
</ul>
<p><strong>問題点</strong> :</p>
<ul>
<li>所要時間 (= ポーズ時間) が unbounded.
<ul>
<li>Root set の大きさは unbounded．</li>
<li>(厳密にはメモリ+ディスクの量で抑えられる．)</li>
</ul></li>
</ul>
<p><strong>対処</strong> :</p>
<ul>
<li>各手法を見る際に述べる．</li>
</ul>
<h2 id="yuasa-の手法">Yuasa の手法</h2>
<div class="flex55">
<div class="flex-left">
<ul>
<li>Write-barrier の種別 : Snapshot．</li>
<li>任意色→白 が貼られたら子を灰に．</li>
</ul>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Algo. 8.1 Yuasa's snapshot write-barrier</figcaption><pre><code class="cpp">// 白セルが渡されたら灰にする．
void shade(Cell *p) {
  if (p.marked()) return;
  p.mark();
  mark_stack.push(p);
}

// もともと指していた先を灰に塗る
void update(Cell **a, Cell *b) {
  if (phase == MARK_PHASE) shade(*a);
  *a = b;
}</code></pre></figure>
</div>
</div>
<h3 id="yuasa--新規セルの扱い">Yuasa | 新規セルの扱い</h3>
<div class="flex55">
<div class="flex-left">
<p>スイープ済みなら白，未スイープなら黒．</p>
<div id="yuasa-new">

<figure><pre><code class="nohljsln txt">         swept      not swept yet
Heap |-------------xxxxxxxxxxxxxxxx|
      ↑            ↑ ここから確保するときは黒
    ここから確保するときは白</code></pre></figure>
</div>
<p>仮にスイープ済みも黒にした場合 :</p>
<ul>
<li>そのセルは次サイクルで回収不能．</li>
<li>→ 一時的なメモリリーク．</li>
</ul>
<p>トレードオフ :</p>
<ul>
<li>スイープ済みかチェックするコスト vs メモリリーク</li>
</ul>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Yuasaのnew</figcaption><pre><code class="cpp">Cell* New() {
  /* -- snip -- */
  Cell *temp = allocate();
  free_count--;

  if (temp &gt;= sweeper) temp-&gt;mark();
  else temp-&gt;unmark();

  return temp;
}</code></pre></figure>
</div>
</div>
<h3 id="yuasa--free-list-の利用">Yuasa | Free list の利用</h3>
<ul>
<li>Lazy sweep は所要時間が unbounded．</li>
<li>→ Free list を使う．
<ul>
<li>Free list 上のセルとゴミを区別する必要が出る．</li>
<li>Free list 上のセルに4つめの色 off-white を塗る．</li>
</ul></li>
</ul>
<h3 id="yuasa--初期化処理">Yuasa | 初期化処理</h3>
<div class="flex64">
<div class="flex-left">
<p><strong>スタック :</strong><br></p>
<ul>
<li>ポインタか否かに依らず，全て <code>saved_stack</code> にコピー．
<ul>
<li><code>memcpy</code> 等を用いて高速にコピー．
<ul>
<li>(ポインタか否かを判別しないことでコスト減を図っているのか，そもそも判別する術がないのかは不明．)</li>
</ul></li>
<li><code>saved_stack</code> は少しずつ <code>mark_stack</code>
に移していく．</li>
</ul></li>
</ul>
<p><strong>レジスタ, グローバル変数 :</strong><br></p>
<ul>
<li><code>mark_stack</code> に直接コピー．</li>
</ul>
<p><strong>巨大な配列 :</strong></p>
<ul>
<li>手段1 : スタックと同様にコピー．</li>
<li>手段2 : ヘッダとボディに分割．
<ul>
<li>ヘッダは incremental mark sweep で管理．</li>
<li>ボディは copy GC で管理 (→ 断片化緩和)．</li>
</ul></li>
</ul>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Yuasa の初期化</figcaption><pre><code class="cpp">phase = MARK_PHASE;
sweeper = Heap_bottom;
for (Cell* r: roots)
  mark_stack.push(r);
block_copy(system_stack, save_stack);</code></pre></figure>
</div>
</div>
<h3 id="yuasa--リアルタイム性">Yuasa | リアルタイム性</h3>
<div class="flex55">
<div class="flex-left">
<div class="sticky">
<p>Yuasa は彼のシステムが real-time だと主張．<br> (根拠 : 計算量が定数
k1, k2, k3 の式で抑えられるから．)</p>
<ul>
<li>Mark phase :
<ul>
<li>セルを k1 個処理 (3行目)．</li>
<li>セルを k2 個 <code>save_stack</code> から <code>mark_stack</code>
に移す (14行目)．</li>
</ul></li>
<li>Sweep phase :
<ul>
<li>セルを k3 個処理 (17行目)．</li>
</ul></li>
</ul>
<p>しかし，その経験的な証拠は無い．</p>
<ul>
<li>例えば，<code>saved_stack</code>
の初期化がその時間内に収まるか不明．</li>
</ul>
</div>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Yuasa のnew</figcaption><pre><code class="cpp">Cell* New() {
  if (phase == MARK_PHASE) {
    if (!mark_stack.is_empty()) mark(k1);
    if ( mark_stack.is_empty()
      &amp;&amp; save_stack.is_empty()) {
      phase = SWEEP_PHASE;
    } else {
      // save_stack から mark_stack に
      // k2 だけ要素を移動
      //
      // save_stack :
      //   GCサイクル開始時の
      //   プログラムスタックのコピー
      transfer(k2);
    }
  } else if (phase == SWEEP_PHASE) {
      sweep(k3);
      if (sweeper &gt; Heap_top) phase = IDLING
  } else if (free_count &lt; threshold) {
    phase = MARK_PHASE;
    sweeper = Heap_bottom;
    for (Cell* r: roots) mark_stack.push(r);
    block_copy(system_stack, save_stack);
  }
  if (free_count == 0) abort(&quot;Heap exhausted.&quot;);

  Cell *temp = allocate();
  free_count--;

  if (temp &gt;= sweeper) temp-&gt;mark();
  else temp-&gt;unmark();

  return temp;
}</code></pre></figure>
</div>
</div>
<h3 id="yuasa--コード一覧">Yuasa | コード一覧</h3>
<details>
<summary>コード一覧</summary>


<figure><figcaption class="code-caption">Algo. 8.1 Yuasa's snapshot write-barrier</figcaption><pre><code class="cpp">// 白セルが渡されたら灰にする．
void shade(Cell *p) {
  if (p.marked()) return;
  p.mark();
  mark_stack.push(p);
}

// もともと指していた先を灰に塗る
// usage: update(&amp;node_a-&gt;child, node_b)
void update(Cell **a, Cell *b) {
  if (phase == MARK_PHASE) shade(*a);
  *a = b;
}</code></pre></figure>

<figure><figcaption class="code-caption">Algo. 8.2 Auxiliary procedures for Yuasa's algorithm.</figcaption><pre><code class="cpp">// Move cells from save_stack to mark_stack.
// k2 : Upper bound of #cell to move.
void transfer(int k2) {
  int i = 0;
  while (i &lt; k2 &amp;&amp; !save_stack.is_empty()) {
    Cell *p = save_stack.pop();
    if (p != nullptr) mark_stack.push(p);
    i += 1;
  }
}

// k3 : Upper bound of #cell to check.
void sweep(int k3) {
  int i = 0;
  while (i &lt; k3 &amp;&amp; sweeper &lt;= Heap_top) {
    if (sweeper.marked()) {
      sweeper.unmark();
      sweeper++;
    } else {
      free(sweeper);
      free_count++;
    }
    i += 1;
  }
}</code></pre></figure>

<figure><figcaption class="code-caption">Algo. 8.3 Yuasa's allocator.</figcaption><pre><code class="cpp">// k1 : Upper bound of #cell to trace.
void mark(int k1) {
  int i = 0;
  while (i &lt; k1 &amp;&amp; !mark_stack.is_empty()) {
    Cell *p = mark_stack.pop();
    for (Cell *q : p-&gt;children()) {
      if (!q-&gt;marked()) {
        q-&gt;mark();
        mark_stack.push(q);
      }
    }
    i += 1;
  }
}

Cell* New() {
  if (phase == MARK_PHASE) {
    if (!mark_stack.is_empty()) mark(k1);
    if (mark_stack.is_empty() &amp;&amp; save_stack.is_empty()) {
      phase = SWEEP_PHASE;
    } else {
      // save_stack から mark_stack に k2 だけ要素を移動
      // save_stack : GCサイクル開始時のプログラムスタックのコピー
      transfer(k2);
    }
  } else if (phase == SWEEP_PHASE) {
      sweep(k3);
      if (sweeper &gt; Heap_top) phase = IDLING
  } else if (free_count &lt; threshold) {
    phase = MARK_PHASE;
    sweeper = Heap_bottom;
    for (Cell* r: roots) mark_stack.push(r);
    block_copy(system_stack, save_stack);
  }
  if (free_count == 0) abort(&quot;Heap exhausted.&quot;);

  Cell *temp = allocate();
  free_count--;

  if (temp &gt;= sweeper) temp-&gt;mark();
  else temp-&gt;unmark();

  return temp;
}</code></pre></figure>
</details>

<h2 id="dijkstra-の方法">Dijkstra の方法</h2>
<div class="flex55">
<div class="flex-left">
<ul>
<li>哲学 : 回収率 &lt;&lt; <strong>単純さ (証明の容易さ)</strong>
<ul>
<li>Mutator は <code>Update</code> しかできない．</li>
<li><code>New</code> は <code>Update</code> の組み合わせ．
<ul>
<li>Free list は到達可能．</li>
<li>→ Free listもマークする必要あり．</li>
</ul></li>
</ul></li>
</ul>
<p></p>

<ul>
<li>Write-barrier の種別 : Incremental (子を塗る)
<ul>
<li>任意色→白 が貼られたら子を灰に．</li>
<li>親が黒でなくても子を塗るので，かなり保守的．</li>
</ul></li>
</ul>
<p></p>

<ul>
<li>新規セルの扱い :
<ul>
<li>Free list の先頭要素の色 (灰 or 黒) を継ぐ．</li>
<li>フェーズごとの区別なし．</li>
</ul></li>
</ul>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Algo. 8.4 Dijkstra's write-barrier</figcaption><pre><code class="cpp">void shade(Cell *p) {
  if (p-&gt;color() == WHITE) p-&gt;set_color(GRAY);
}

void Update(Cell **a, Cell *b) {
  *a = b;
  shade(b);
}</code></pre></figure>
</div>
</div>
<h3 id="dijkstra--初期化処理">Dijkstra | 初期化処理</h3>
<ul>
<li><strong>対処不要</strong>．</li>
<li>初期化処理は Mutator と並列に走る．</li>
<li>→ 初期化処理が長くとも mutator はポーズしない．</li>
</ul>
<h3 id="dijkstra--mark-の終了判定">Dijkstra | Mark の終了判定</h3>
<div class="flex55">
<div class="flex-left">
<p>ヒープを走査して灰が無かったら終了．</p>
<ul>
<li>灰が見つかったら，そのセルを訪問 (10行目)．
<ul>
<li>そのセルの子しか見ない (孫以降は見ない)．</li>
</ul></li>
<li>計算量はアクティブなデータ構造の2次式．</li>
</ul>
<p>計算量が2次式になる例 :</p>
<p><img src="img/dijkstra-worst-case.dio.svg" /></p>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Dijkstra の mark (参考 : <a href='https://lamport.azurewebsites.net/pubs/garbage.pdf'>Dijkstraの論文</a>)</figcaption><pre><code class="cpp">shade_all_roots();
int idx = 0;
int num_cells = sizeof(HEAP) / sizeof(Cell);
int left_to_scan = num_cells;

while (left_to_scan &gt; 0) {
  Cell *cell = *(HEAP_BOTTOM + idx);
  if (cell-&gt;color == GRAY) {
    left_to_scan = num_cells;
    for (Cell *c: cell-&gt;children()) {
      c-&gt;color = GRAY;
    }
    cell-&gt;color = BLACK;
  } else {
    left_to_scan -= 1;
  }
  i = (i + 1) % num_cells;
}</code></pre></figure>
</div>
</div>
<h3 id="dijkstra--並列処理">Dijkstra | 並列処理</h3>
<div class="flex55">
<div class="flex-left">
<div class="sticky">
<p><code>Update</code> の各命令が atomic であれば，このアルゴリズムは
mutator と並列に動かせる． (真偽は後述)</p>
<p>Q. ポインタ更新直後に一貫性が破れないか？<br> A.
確かに破れるが，<code>*a = b</code> と <code>shade(b)</code>
を入れ替えると並列に動かせなくなる．</p>
<p>右図は <code>shade(b)</code>，<code>*a = b</code>
の順で実行した際にバグる例．</p>
</div>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Algo. 8.4 Dijkstra's write-barrier</figcaption><pre><code class="cpp">void shade(Cell *p) {
  if (p-&gt;color() == WHITE) p-&gt;set_color(GRAY);
}

void Update(Cell **a, Cell *b) {
  *a = b;
  shade(b);
}</code></pre></figure>
<p><img src="img/dijkstra-failed.dio.svg" style="width:50.0%" /></p>
</div>
</div>
<h4
id="元の順序だと本当に並列に動かせるか--怪しい">元の順序だと本当に並列に動かせるか？
→ 怪しい</h4>
<p>元論文を見ると，<code>Update</code> そのものを atomic
と仮定している気がする．</p>
<blockquote>
<p>we introduce the notion of “atomic operations,” denoted in this paper
by a piece of program placed between a pair of angle brackets</p>
</blockquote>
<blockquote>
<p>Our choice was a coarsegrained mutator that repeatedly performs the
following atomic operation, in which “shading a node” means making it
gray if it is white, and leaving it unchanged if it is gray or
black:</p>
<p>MI: &lt;redirect an outgoing edge of a reachable node towards an
already reachable one, and shade the new target&gt;</p>
</blockquote>
<h2 id="steele-の方法">Steele の方法</h2>
<div class="flex55">
<div class="flex-left">
<ul>
<li>哲学 : <strong>回収率</strong> &gt;&gt; 単純さ (証明の容易さ)</li>
<li>Write-barrier の種別 : Incremental (親を塗る)</li>
</ul>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Algo. 8.5 Steele's write-barrier.</figcaption><pre><code class="cpp">void shade(Cell *p) {
  p-&gt;unmark();
  gcpush(p, mark_stack);
}

// usage : update(&amp;node_a, &amp;node_a-&gt;child, node_c);
void update(Cell *parent, Cell **a, Cell *c) {
  LOCK gcstate {
    *a = c;
    if (phase == MARKING_PHASE) {
      if (parent-&gt;is_marked() &amp;&amp; !c-&gt;is_marked()) {
        shade(parent);
      }
    }
  }
}</code></pre></figure>
</div>
</div>
<h3 id="steele--新規セルの扱い">Steele | 新規セルの扱い</h3>
<div class="flex55">
<div class="flex-left">
<h4 id="新規セルの作り方-create-の動作">新規セルの作り方
(<code>create</code> の動作)</h4>
<p><code>struct { void *c1; void *c2; }</code> を作る例．</p>
<ol type="1">
<li><code>c1</code>, <code>c2</code> をスタックに積む．</li>
<li><code>Create(2)</code> を呼ぶ．</li>
</ol>
<p><img src="img/steele-alloc.dio.svg" /></p>
<h4 id="色の付け方">色の付け方</h4>
<p>フェーズごとに区別する．</p>
<p><strong>MARK_PHASE :</strong><br></p>
<ul>
<li>すべての子がマークされていたら黒に．</li>
<li>それ以外は灰に．</li>
</ul>
<p><strong>SWEEP_PHASE :</strong><br></p>
<ul>
<li>Sweeper がすでに通過していたら白に．</li>
<li>それ以外は黒に．
<ul>
<li>(Yuasaと同じ)</li>
</ul></li>
</ul>
<p><clone ref="yuasa-new"></clone></p>
<p><strong>その他 :</strong><br></p>
<ul>
<li>白に．</li>
</ul>
</div>
<div class="flex-right">
<div class="sticky">

<figure><figcaption class="code-caption">Algo 8.6 Steele's allocation.</figcaption><pre><code class="cpp">void push(Cell *p, Stack *stack) {
  LOCK program_stack {
    stack[++stack_index] = p;
    if ( phase == MARK_PHASE
      &amp;&amp; stack.is_marked()
      &amp;&amp; !x.is_marked()
    ) {
      gcpush(p, mark_stack);
    }
  }
}

// Create new cell with n fields
void create(int n) {
  Lock gcstate {
    Cell *temp = allocate();
    LOCK temp {
      bool newmark = true;
      if (phase == SWEEP_PHASE)
        newmark = sweeper &lt;= temp;
      for (int i = 1; i &lt; n; ++i) {
        Cell *p = pop();
        temp[i] = p;
        if (phase == MARK_PHASE)
          newmark = newmark &amp; mark_bit(p);
      }
      mark_bit(temp) = newmark;
      push(temp, stack);
    }
  }
}</code></pre></figure>
</div>
</div>
</div>
<h3 id="steele--初期化処理--mark-の終了条件">Steele | 初期化処理 &amp;
Mark の終了条件</h3>
<div class="flex55">
<div class="flex-left">
<div class="sticky">
<h4 id="初期化処理-">初期化処理 :</h4>
<ol type="1">
<li>Root (LISP の <code>oblist</code>) から辿れるセルをマーク．
<ul>
<li><code>oblist</code> : シンボルを管理するリスト．</li>
<li>(参考 : <a
href="https://dl.acm.org/doi/pdf/10.1145/361002.361005">元論文</a>)</li>
</ul></li>
<li>スタックから辿れるセルをマーク．
<ul>
<li>スタック上の要素 Root よりは短命だろう．</li>
<li>→ Root より後に処理で回収率 UP．</li>
</ul></li>
</ol>
<p>その他 <code>mark_stack</code> に適宜積むもの :</p>
<ul>
<li><code>system_stack</code> のマーク後に mutator が，
<ul>
<li><code>system_stack</code> に積んだセル．</li>
<li><code>create</code> で確保したセル．</li>
</ul></li>
</ul>
<h4 id="mark-の終了条件-">Mark の終了条件 :</h4>
<ul>
<li><code>mark_stack</code> が空になったら．</li>
</ul>
</div>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Algo. 8.7 Steele's concurrent marker.</figcaption><pre><code class="cpp">void mark() {
  phase = MARK_PHASE;
  for (Cell *r: Roots) {
    gcpush(r, mark_stack);
    mark1();
  }
  for (Cell *s: system_stack) {
    LOCK s, system_stack {
      gcpush(s, mark_stack);
    }
    mark1();
  }
  LOCK gcstate {
    finished = mark_stack-&gt;is_empty();
  }
  while (!finished) {
    mark1();
    LOCK gcstate
      finished = mark_stack-&gt;is_empty();
  }
}

void mark1() {
  while (!mark_stack-&gt;is_empty()) {
    Cell *x = gcpop(mark_stack);
    if (x-&gt;marked()) return;
    LOCK x {
      for (Cell *y: x-&gt;children()) {
        gcpush(y, mark_stack)
        x-&gt;mark();
      }
    }
  }
}</code></pre></figure>
</div>
</div>
<h2 id="kung-and-song-の手法">Kung and Song の手法</h2>
<div class="flex55">
<div class="flex-left">
<ul>
<li>哲学 : <strong>回収率</strong> &gt;&gt; 単純さ (証明の容易さ)</li>
<li>Dijkstra の手法を改良したもの．</li>
</ul>
<p><strong>改良点</strong><br></p>
<ul>
<li><strong>Free list はマークしない．</strong>
<ul>
<li>Sweep 時に free セルを off-white で塗る．</li>
<li>(Yuasa と同じ)</li>
</ul></li>
<li><strong>スタックではなく output restricted deque を使う．</strong>
<ul>
<li>→ クリティカルセクションの削減．</li>
</ul></li>
<li><strong>Queue 中のセルは初めから黒にしておく．</strong>
<ul>
<li>Queue 中のセルは必ず訪問される．</li>
<li>→ 実際には「灰」でも黒く塗って問題ない．</li>
</ul></li>
</ul>
<div class="note">
<div class="indent">
<p>Output restricted deque : 両端キューの一種．</p>
<ul>
<li>削除は片方の口から</li>
<li>挿入は両方の口から</li>
</ul>

<figure><pre><code class="nohljsln txt">               Output restricted deque
               +-------------------+ &lt;----
 mutator ----&gt; | | | | | | | | | | |         GC
               +-------------------+ ----&gt;</code></pre></figure>
</div>
</div>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Algo. 8.8(1) Kung and Song mutator code.</figcaption><pre><code class="cpp">void shade(Cell *p) {
  if (white(p) || off_white(p)) {
    colour(p) = grey;
    gcpush(p, queue.mutator_end())
  }
}

void update (a, c) {
  *a = c
  if phase == MARK_PHASE
    shade(c)
}</code></pre></figure>
</div>
</div>
<h3 id="kung-and-song--新規セルの扱い">Kung and Song |
新規セルの扱い</h3>
<div class="flex55">
<div class="flex-left">
<p><strong>MARK_PHASE :</strong></p>
<ul>
<li>灰に．</li>
</ul>
<p><strong>その他 :</strong></p>
<ul>
<li>白に．</li>
</ul>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Algo. 8.8(2) Kung and Song mutator code.</figcaption><pre><code class="cpp">Cell* New() {
  Cell *temp = allocate();
  if (phase == MARK_PHASE) {
    colour(R) = black;
  }
  return temp;
}</code></pre></figure>
</div>
</div>
<h3 id="kung-and-song--初期化処理--mark-の終了条件">Kung and Song |
初期化処理 &amp; mark の終了条件</h3>
<div class="flex55">
<div class="flex-left">
<h4 id="初期化処理--1">初期化処理 :</h4>
<p><strong>対処不要</strong>．</p>
<ul>
<li>Mutator と並列に走る．</li>
<li>→ 初期化が長くとも mutator はポーズしない．</li>
</ul>
<h4 id="mark-の終了条件--1">Mark の終了条件 :</h4>
<ul>
<li>Queue が空になったら．</li>
</ul>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Algo. 8.9 The Kung and Song marker.</figcaption><pre><code class="cpp">void mark() {
  phase = MARK_PHASE;
  while (!queue.is_empty()) {
    Cell *n = (node at gc_end of queue);
    colour(n) = black;
    gcpop(queue);
    for (auto m: n-&gt;children()) {
      if !black(*m) {
        colour(*m) = black;
        gcpush(*m, gc_end of queue);
      }
    }
  }
  phase = SWEEP_PHASE;
}</code></pre></figure>
</div>
</div>
<h2 id="まとめ">まとめ</h2>
<p><clone ref="compare-table"></clone></p>
<h2 id="mark-と-sweep-を並列に動かす-パイプライン処理">Mark と Sweep
を並列に動かす (パイプライン処理)</h2>
<h3 id="quinnec-のアルゴリズム">Quinnec のアルゴリズム</h3>
<div class="flex55">
<div class="flex-left">
<p>Dijkstra の拡張的な位置づけと思われる．</p>
<ul>
<li>Incremental (子を塗る)</li>
<li>n サイクル目の sweep と n+1 サイクル目の mark を並列実行．</li>
<li>セルは2つのカラーフィールドを持つ．
<ul>
<li>1つ目 : 偶数番目のサイクル用．</li>
<li>2つ目 : 奇数番目のサイクル用．</li>
</ul></li>
</ul>
</div>
<div class="flex-right">

<figure><pre><code class="nohljsln txt">time -------------------------------------------&gt;
                mark       sweep
  cycle n   &lt;----------|==========&gt;
  cycle n+1            &lt;----------|==========&gt;
  ...</code></pre></figure>
</div>
</div>
<p>特徴 :</p>
<ul>
<li>Free list は到達可能 (Dijkstra と同じ)
<ul>
<li>→ Free list も mark する必要がある．(参考 : <a
href="https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=9DA2EF63E07715A5140538225D5E57D3?doi=10.1.1.42.5135&amp;rep=rep1&amp;type=pdf">元論文</a>)</li>
</ul></li>
</ul>
<p>注意すべき問題 :</p>
<ul>
<li>黒→白 が有ってはならない．</li>
<li>Sweep 側が開放したセル (→ free list 行き) も，mark
側でマークしなくてはならない．</li>
<li>何も対処しないと，sweep 時点でゴミ → mark 側でもゴミ
なのでマークされない．</li>
</ul>
<p>対策 :</p>
<ul>
<li>n サイクル目の sweep が白を開放する際は，n+1 サイクル用の色を shade
する．</li>
</ul>
<h3 id="lamport-のアルゴリズム">Lamport のアルゴリズム</h3>
<ul>
<li>Mark と sweep を 並列実行．</li>
<li>Multiple GC を許可．</li>
<li>Queinnec と違い，各 marker と各 sweeper
は1つのカラーフィールドを共有．
<ul>
<li>Sweeper はゴミと確定したものを解放する．</li>
<li>Marker はゴミを訪問しない．</li>
<li>→ Sweeper と marker は競合しない． (ただし free list
の扱いは注意)</li>
</ul></li>
</ul>
<p>問題点 :</p>
<ul>
<li>Mark 開始時は全セルを白にする必要があるが， sweep
側は白を見つけると開放してしまう．
<ul>
<li>Quinnec の手法は marker/sweeper
が違うカラーフィールドを使うため，この問題は起きない．</li>
</ul></li>
</ul>
<p>解決策 :</p>
<ul>
<li>新たな mark/scan のペアが走る前にセルを塗り替える．
<ul>
<li>白を紫に，黒を白か灰に．</li>
</ul></li>
<li>実装としてはカラーフィールドの解釈を変えれば良い．
<ul>
<li>e.g カラーフィールドの値「0x00」の解釈を，白から紫に変える．</li>
<li>1命令で可能 (全セルを塗りに訪問しなくて良い)．</li>
</ul></li>
</ul>
<h2 id="virtual-memory-techniques">Virtual memory techniques</h2>
<p>ソフトウェアでの write-barrier は重い．<br> →
仮想メモリの助けを借りてオーバーヘッドを減らす．</p>
<h3 id="dirty-bit-の利用">Dirty bit の利用</h3>
<p>Boehm-Demers-Shenker の手法 (9章):</p>
<ul>
<li>Incremental に mark する手法．</li>
<li>OS の dirty bits に依存した同期をおこなう
(7章と概ね同じと思われる)．</li>
<li>Cedar における (比較的制約の緩い)
アプリで，ポーズ時間を大幅に改善．</li>
</ul>
<p>利点 :</p>
<ul>
<li>Dirty bits の検査はトラップが起きない．
<ul>
<li>(オーバーヘッドの主な要素はGCによるページのスキャン．)</li>
</ul></li>
<li>コンパイラの助けが不要．</li>
</ul>
<p>欠点 :</p>
<ul>
<li>精度が荒い．</li>
<li>Hard real-time システムでは使えない．
<ul>
<li>終了を試みるときに mutator を止める．</li>
<li>Dirty bits の検査やページのスキャンは重い．</li>
</ul></li>
</ul>
<h3 id="copy-on-write-cow-の利用">Copy On Write (COW) の利用</h3>
<p>Furusou らの snapshot を用いた手法．</p>
<ul>
<li>COW によってインクリメンタルに snapshot を取る．
<ul>
<li>ヒープの仮想コピーを mark フェーズ開始時に取る．</li>
<li>Mutator があるページに書き込むと，COW によりそのページの snapshot
が撮れる．</li>
<li>マークは Yuasa と同様に行う．</li>
</ul></li>
</ul>
<div class="note indent">
<p>COW : コピーを遅延させる手法．</p>
<ul>
<li>はじめは参照を持っておき，書き込みがあったらコピーを生成する．</li>
</ul>
</div>
<p><strong>利点 :</strong></p>
<ul>
<li>ポーズ時間が短い．
<ul>
<li>ポーズするのは COW の準備にかかる時間だけ．</li>
</ul></li>
<li>Mutator と collector の間で同期をとる必要なし．
<ul>
<li>Q. COW しない手法で同期が必要だったのはなぜか？</li>
<li>A. <quiz>Mutator と collector
がメモリ領域を共有していたため．</quiz></li>
</ul></li>
</ul>
<p><strong>欠点 :</strong></p>
<ul>
<li>オブジェクトがコピーされる．</li>
<li>非常に保守的である (GCサイクル中に死んだセルは回収不能)．</li>
<li>パフォーマンスが出ない．
<ul>
<li>必要な割当速度 : 数百万オブジェクト / 秒</li>
<li>実際の割当速度 : 数千オブジェクト / 秒</li>
</ul></li>
</ul>
<p><strong>パフォーマンスが出ない問題への対処 :</strong></p>
<ul>
<li>原因 : 複数の mutator スレッドが単一の gc
スレッドに割当を要求するため．</li>
<li>対処 : (単一のセルではなく) メモリチャンクを各 mutator
スレッドに渡す．</li>
<li>Mutator はこのチャンクから割当を行う．
<ul>
<li>その間，チャンクは全て生きているとみなす．
<ul>
<li>→ 断片化の恐れ．</li>
</ul></li>
</ul></li>
</ul>
<h2 id="84-concurrent-reference-counting">8.4 Concurrent Reference
Counting</h2>
<p>RC は incremental GC に適している．</p>
<ul>
<li>Mutator と collector が自然にインターリーブする．</li>
</ul>
<p>しかし，ナイーブな RC には問題もある．</p>
<ul>
<li>循環データ構造を扱えない．</li>
<li>ポインタの更新が遅い．
<ul>
<li>特に，concurrent な環境ではカウンタの atomic な操作が必要．</li>
<li>→ より遅く．</li>
</ul></li>
</ul>
<h3 id="modular-2-の-transaction-queue">Modular-2+ の transaction
queue</h3>
<div class="flex64">
<div class="flex-left">
<ul>
<li>Mutator は参照カウンタを触らない．</li>
<li>代わりにポインタの更新を transaction queue に登録．</li>
<li>さらに，deferred reference counting (3章) でコスト減．</li>
</ul>
<p>Deferred reference counting 風の処理．</p>
<ul>
<li>着眼点 : ポインタ更新の多くはスレッドローカル変数に対して．
<ol type="1">
<li>スレッドローカル変数からの参照を数えない．</li>
<li>参照数が 0 なものを ZCL に置く．</li>
<li>最後にスレッドローカル変数からの参照数を調査．</li>
</ol></li>
</ul>
<p>問題点 :</p>
<ul>
<li>(循環参照が扱えない)</li>
<li>スレッド非ローカル変数への書き込みが重い．</li>
</ul>
<p>DeTreville 氏の考察 :</p>
<ul>
<li>参照が重いのでコピーの多用に繋がる．</li>
<li>→ 断片化, メモリ使用量の増加, 局所性の悪化, …</li>
</ul>
</div>
<div class="flex-right">

<figure><figcaption class="code-caption">Algo. 8.10 Mutator code for shared reference assignment</figcaption><pre><code class="cpp">void update(a, c) {
  LOCK mutex {
    insert(a, c, tq);
    if (tq.is_full()) {
      notify_collector(tq);
      tq = get_next_block();
    }
    *a = c;
  }
}</code></pre></figure>

<figure><figcaption class="code-caption">Algo. 8.11 Collector code for shared reference assignment.</figcaption><pre><code class="cpp">void collector() {
  while (true) {
    tq = wait_next_block();
    for (auto th: get_all_thread()) {
      LOCK mutex {
        th.suspend();
        th.scan_thread();
        th.restart();
      }
    }
    tq.adjust_counts();
    tq.free_block();
    adjust_shared_counts();
    process_ZCL();
  }
}</code></pre></figure>
</div>
</div>
<h2 id="まとめ--クイズ">まとめ &amp; クイズ</h2>
<p><strong>Generational GC (7章) について :</strong></p>
<ul>
<li>目的 : <quiz>平均</quiz>ポーズ時間の削減</li>
<li>仮定 : 若い世代は短命</li>
<li>欠点 : 仮定が外れるとポーズ時間が長くなる．</li>
</ul>
<p><strong>Hard real time システムについて :</strong></p>
<ul>
<li>求められる性質 : 絶対に遅れてはいけない (e.g エアバッグ)</li>
<li>→ <quiz>最悪</quiz>ポーズ時間を減らす必要あり．</li>
</ul>
<p><strong>Incremental GC について:</strong></p>
<ul>
<li>目的 : <quiz>最悪</quiz>ポーズ時間の削減．</li>
<li>手法 : Mark / sweep 等を少しずつ行う．</li>
</ul>
<p><strong>Incremental GC で注意すべき点 :</strong></p>
<ul>
<li>一貫性の問題 :
<ul>
<li>Mutator
が，<quiz>黒</quiz>色から<quiz>白</quiz>色へのポインタを貼る恐れがある．</li>
<li>これは，<quiz>そうしたポインタの白は誤って開放される恐れがある</quiz>点で問題．</li>
</ul></li>
<li>初期化処理の問題 :
<ul>
<li>Root のサイズは unbounded．</li>
<li>→ ナイーブにやると初期化処理のポーズ時間も unbounded．</li>
</ul></li>
<li>新規セルの扱い :
<ul>
<li>新規セルを何色にするか？</li>
</ul></li>
</ul>
<p><strong>一貫性の問題への対処 :</strong></p>
<ul>
<li>黒→白 できる前に白を訪問 (read barrier)．</li>
<li>黒→白 を作った際に覚えておく (write barrie)．
<ul>
<li>Snapshot-at-the-beginning :
<ul>
<li>参照を消す際に，もともと参照されていたノードを訪問．</li>
</ul></li>
<li>Incrementa-update :
<ul>
<li>参照を書き込む際に，そのエッジの親 or 子を訪問．</li>
</ul></li>
</ul></li>
</ul>
<p><img src="img/write-barrier.dio.svg" /></p>
<p><strong>保守の度合い</strong><br></p>
<div class="flex64">
<div class="flex-left">
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">Snapshot</th>
<th style="text-align: center;">Incremental (子を塗る)</th>
<th style="text-align: center;">Incremental (親を塗る)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">全回収</td>
<td style="text-align: center;">全回収</td>
<td style="text-align: center;">全回収</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;"><quiz>回収しない</quiz></td>
<td style="text-align: center;"><quiz>部分的に回収</quiz></td>
<td
style="text-align: center;">子を塗る場合より<quiz>多く</quiz>回収</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">(新規セルの扱いに依存)</td>
<td style="text-align: center;">(新規セルの扱いに依存)</td>
<td style="text-align: center;">(新規セルの扱いに依存)</td>
</tr>
</tbody>
</table>
</div>
<div class="flex-right">
<p>ゴミの分類の図 : <img src="img/lifetime.dio.svg" /></p>
</div>
</div>
<p><strong>その他のテクニック</strong></p>
<ul>
<li>Mark と sweep のパイプライン処理</li>
<li>仮想メモリの利用
<ul>
<li>Dirty bit</li>
<li>ページの copy on write による snapshot</li>
</ul></li>
</ul>
</body>
</html>
