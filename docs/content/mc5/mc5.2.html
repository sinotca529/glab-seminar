<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

  <link rel="stylesheet" type="text/css" href="../../style.css">
  <script type="text/javascript" src="../../script.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>

  <!-- and it's easy to individually load additional languages -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/cpp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/llvm.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/makefile.min.js"></script>

  <script>
    hljs.highlightAll();
    hljs.initLineNumbersOnLoad();
  </script>

  <!-- mermaid.js -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({startOnLoad: true});</script>

  <!-- pseudocode.js -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css">
  <script src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js"></script>
  <script>
    window.addEventListener("DOMContentLoaded", function() {
      document.querySelectorAll(".algorithm")
        .forEach(e => pseudocode.renderElement(e, {lineNumber: true, lineNumberPunc: ' '}));
    });
  </script>

  <!-- viz.js (graphviz) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/1.8.2/viz.js"></script>
  <script>
    window.addEventListener("DOMContentLoaded", function() {
      document.querySelectorAll(".graphviz")
        .forEach(e => e.innerHTML = Viz(e.innerText));
    });
  </script>

  <title>Model Checking (Sec.5.2)</title>
  <meta name="keywords" content="MC"/>
  <meta name="date" content="yyyy-mm-dd"/>

  <style type="text/css">
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" />
</head>
<body>
<a href="../../index.html">トップへ</a>
<p>
  <date>yyyy-mm-dd</date>
      <tag><a href="../../tag.html?tag=MC">MC</a></tag>
  </p>

<h1 id="52-model-checking-ctl-with-fairness-constraints">5.2
Model-Checking CTL with Fairness Constraints</h1>
<dl>
<dt>この節の目的:</dt>
<dd>
Fairness constraints を扱えるよう、5.1節の手法を拡張すること。
</dd>
</dl>
<p>この節では、Fiarness constraints を <span class="math inline">F = \{
P_1, \cdots, P_k\}</span> と書く。</p>
<h2 id="概要">概要</h2>
<p>CTL式は、¬, ∧, ∨, EG, EX, EU のみの形に変形(正規化)できる。<br>
よって、5.1節と同じく、これらを処理する関数を設計すれば良い。</p>
<p>このうち、¬, ∧, ∨ については5.1節で設計した関数を流用できる。</p>
<p>この節では、残るEG, EX, EUについて考える。</p>
<h2 id="textbfe_ftextbfgの処理"><span
class="math inline">\textbf{E}_f\textbf{G}</span>の処理</h2>
<h2 id="用語--公平なscc">用語 : 公平なSCC</h2>
<p>クリプキ構造<span class="math inline">M</span>上のSCC <span
class="math inline">C</span> が次を満たすとき、 <span
class="math inline">C</span> は <span class="math inline">F</span>
について公平であるという。 <span class="math display"> \forall P_i \in
F,\ \exist t_i \in (C \cup P_i) </span></p>
<h2 id="記法">記法</h2>
<p>クリプキ構造<span class="math inline">M</span>のうち、<span
class="math inline">f_1</span>を公平に満たすノードのみを残したクリプキ構造を、<span
class="math inline">M&#39;</span>と呼ぶ。 <span class="math display">
\begin{align*}
M&#39; = &amp;(S&#39;, R&#39;, L&#39;, F&#39;) \ \ \text{ where}\\
&amp;S&#39; = \{s\in S | M,s\vDash_F f_1\},\\
&amp;S&#39; = R&#39; = R|_{S&#39;\times S&#39;},\\
&amp;S&#39; = L&#39; = L|_{S&#39;},\\
&amp;S&#39; = F&#39; = \{P_i \cup S&#39; \ |\ P_i \in F\}
\end{align*}
</span></p>
<h2 id="lemma-53">Lemma 5.3</h2>
<p><span class="math inline">M,s \vDash_F \textbf{E}_F\textbf{G}
f_1</span>と、次の2条件を両方満たすことは同値</p>
<ol type="1">
<li><span class="math inline">s \in S&#39;</span></li>
<li><span class="math inline">M&#39;</span>上に、<span
class="math inline">s</span>からグラフ<span class="math inline">(S&#39;,
R&#39;)</span>の公平なMSCC上のノード<span
class="math inline">t</span>までのパスが存在</li>
</ol>
<p>(証明は Lemma 5.1 と同様のため省略。)</p>
<h2 id="アルゴリズム">アルゴリズム</h2>
<p>Lemma 5.3 を使うことで、<code>CheckFairEG</code>を作成できる。<br>
<code>CheckEG</code>との違いは、MSCCを用いるか、Fair MSCC
を用いるかだけである。</p>

<figure><figcaption class="code-caption">CheckFairEG</figcaption><pre><code class="py">def CheckFairEG(f1):
    S’ = { s ∈ S | f1 ∈ label(s) }
    FairMSCCs = get_all_fair_mscc(S’)
    T = ∪FiarMSCCs

    while T != ∅:
        s = T.pop()
        for t in s.parents():
            if (t ∈ S’) and (EG f1 ∉ label(t))
                label(t) += EG f1
                T += t</code></pre></figure>
<h2 id="計算量">計算量</h2>
<p>Fair MSCCを求める部分は、例えば次のように実装できる。</p>

<figure><pre><code class="py">def get_all_fair_mscc(S):
    FairMSCCs = ∅
    MSCCs = get_all_mscc(S)

    # key: 状態
    # value: その状態を含む P_i (∈ F) の集合
    d = {}

    # O(|F||S|)
    for P in Fair {
        for s in P {
            d[s] ∪= P
        }
    }

    for m in MSCCs {
        local = ∅
        for s in m:
            local ∪= map[s]
        if local.len() == |F|:
            FairMSCCs ∪= m
    }

    return FairMSCCs</code></pre></figure>
<p>公平性を検査する必要があるため、計算量は<span
class="math inline">O((|S| + |R|)\cdot|F|)</span>に増加。</p>
<h2 id="ex-eu">EX, EU</h2>
<p>他のCTL式を公平クリプキ構造の元で検証するため、特別な原子式 <span
class="math inline">\textit{fair}</span> を定義する。 <span
class="math display"> s \vDash \textit{fair} \iff \text{(There is a fair
path starting from } s \text{. )} </span></p>
<p>なお、<span class="math inline">\textit{fair} =
\textbf{E}_F\textbf{G}\textit{true}</span> である。</p>
<p><span class="math inline">M,s \vDash_F
\textbf{E}_f\textbf{X}f_1</span>を検査するには、 <span
class="math inline">M,s \vDash \textbf{EX}(f_1  \land
\textit{fair})</span>を調べれば良い。</p>
<p><span class="math inline">M,s \vDash_F \textbf{E}_f(f_1 \textbf{U}
f_2)</span>を検査するには、 <span class="math inline">M,s \vDash
\textbf{E}(f_1 \textbf{U} (f_2 \land
\textit{fair})))</span>を調べれば良い。</p>
<p>各ステップの計算量は<span class="math inline">O((|S| +
|R|)\cdot|F|)</span>なので、全体の計算量は<span
class="math inline">O(|f|\cdot(|S| + |R|)\cdot|F|)</span>である。</p>
<h2 id="theorem-54">Theorem 5.4</h2>
<p>クリプキ構造<span class="math inline">M = (S, R, L,
F)</span>とCTL式<span class="math inline">f</span> について、<span
class="math inline">M \vDash_F f</span> を<span
class="math inline">O(|f|\cdot(|S| + |R|)\cdot|F|)</span>
で調べるアルゴリズムが存在する。</p>
<h2 id="具体例">具体例</h2>
<p><span class="math inline">F = \{\{ s \ |\  s \vDash \textit{Start}
\land \textit{Close} \land \neg\textit{Error}\}\}</span>とおく。</p>
<p>5.1節と似た、次の式を調べる。 <span class="math display">
\textbf{A}_f\textbf{G}(\textit{Start} \rightarrow
\textbf{A}_f\textbf{F}\textit{Heat}) </span>を調べる。</p>
<h3 id="ステップ1--正規化">ステップ1 : 正規化</h3>
<p><span class="math display"> \textbf{A}_f\textbf{G}(\textit{Start}
\rightarrow \textbf{A}_f\textbf{F}\textit{Heat}) = \neg
\textbf{E}_f(\textit{true} \textbf{U} (\textit{Start} \land
\textbf{E}_f\textbf{G}\neg\textit{Heat}))</span></p>
<h3 id="ステップ2--部分式の列挙">ステップ2 : 部分式の列挙</h3>
<ul>
<li><span class="math inline">\textit{true}</span></li>
<li><span class="math inline">\textit{Start}</span></li>
<li><span class="math inline">\textit{Heat}</span></li>
<li><span class="math inline">\neg\textit{Heat}</span></li>
<li><span
class="math inline">\textbf{E}_f\textbf{G}\neg\textit{Heat}</span></li>
<li><span class="math inline">\textit{Start} \land
\textbf{E}_f\textbf{G}\neg\textit{Heat}</span></li>
<li><span class="math inline">\textbf{E}_f(\textit{true} \textbf{U}
(\textit{Start} \land
\textbf{E}_f\textbf{G}\neg\textit{Heat}))</span></li>
<li><span class="math inline">\neg\textbf{E}_f(\textit{true} \textbf{U}
(\textit{Start} \land
\textbf{E}_f\textbf{G}\neg\textit{Heat}))</span></li>
</ul>
<h3 id="ステップ3--ネストの浅い部分式から順に調べる">ステップ3 :
ネストの浅い部分式から順に調べる</h3>
<ul>
<li><span class="math inline">\llbracket\textit{true}\rrbracket = \{1,
2, 3, 4, 5, 6, 7\}</span></li>
<li><span class="math inline">\llbracket\textit{Start}\rrbracket = \{2,
5, 6, 7\}</span></li>
<li><span class="math inline">\llbracket\textit{Heat}\rrbracket = \{4,
7\}</span></li>
<li><span class="math inline">\llbracket\neg\textit{Heat}\rrbracket =
\{1, 2, 3, 5, 6\}</span></li>
</ul>
<h4 id="llbrackettextbfe_ftextbfgnegtextitheatrrbracket-について"><span
class="math inline">\llbracket\textbf{E}_f\textbf{G}\neg\textit{Heat}\rrbracket</span>
について</h4>
<ol type="1">
<li><span class="math inline">S&#39; = \llbracket \neg\textit{Heat}
\rrbracket = \{1, 2, 3, 5, 6\}</span>と置く</li>
<li><span class="math inline">S&#39;</span>内の公平なMSCCを見つける</li>
<li><span
class="math inline">S&#39;</span>内の状態のうち、MSCC内の状態への経路がある状態を見つける</li>
<li>見つけた状態の集合が<span
class="math inline">\llbracket\textbf{E}_f\textbf{G}\neg\textit{Heat}\rrbracket</span>である</li>
</ol>
<ul>
<li>いま、<span
class="math inline">S&#39;</span>内に公平なMSCCは存在しない</li>
<li>よって、<span
class="math inline">\llbracket\textbf{E}_f\textbf{G}\neg\textit{Heat}\rrbracket
= \emptyset</span></li>
</ul>
<h4
id="llbrackettextitstart-land-textbfe_ftextbfgnegtextitheatrrbracket-llbrackettextbfe_ftextittrue-textbfu-textitstart-land-textbfe_ftextbfgnegtextitheatrrbracket-について"><span
class="math inline">\llbracket\textit{Start} \land
\textbf{E}_f\textbf{G}\neg\textit{Heat}\rrbracket</span>, <span
class="math inline">\llbracket\textbf{E}_f(\textit{true} \textbf{U}
(\textit{Start} \land
\textbf{E}_f\textbf{G}\neg\textit{Heat}))\rrbracket</span> について</h4>
<p><span
class="math inline">\llbracket\textbf{E}_f\textbf{G}\neg\textit{Heat}\rrbracket
= \emptyset</span> なので、 <span class="math display">
\llbracket\textbf{E}_f(\textit{true} \textbf{U} (\textit{Start} \land
\textbf{E}_f\textbf{G}\neg\textit{Heat}))\rrbracket = \emptyset </span>
である。</p>
<h4
id="llbracketnegtextbfe_ftextittrue-textbfu-textitstart-land-textbfe_ftextbfgnegtextitheatrrbracket-について"><span
class="math inline">\llbracket\neg\textbf{E}_f(\textit{true} \textbf{U}
(\textit{Start} \land
\textbf{E}_f\textbf{G}\neg\textit{Heat}))\rrbracket</span> について</h4>
<p><span class="math inline">\llbracket\textbf{E}_f(\textit{true}
\textbf{U} (\textit{Start} \land
\textbf{E}_f\textbf{G}\neg\textit{Heat}))\rrbracket = \emptyset</span>
なので、</p>
<p><span class="math display"> \llbracket\neg\textbf{E}_f(\textit{true}
\textbf{U} (\textit{Start} \land
\textbf{E}_f\textbf{G}\neg\textit{Heat}))\rrbracket = S </span>
である。</p>
</body>
</html>
