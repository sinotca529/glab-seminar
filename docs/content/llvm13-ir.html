<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

  <link rel="stylesheet" type="text/css" href="../style.css">
  <script type="text/javascript" src="../script.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>

  <!-- and it's easy to individually load additional languages -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/cpp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/rust.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/llvm.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/languages/makefile.min.js"></script>

  <script>
    hljs.highlightAll();
    hljs.initLineNumbersOnLoad();
  </script>




  <title>LLVM13 マニュアル抜粋 [wip]</title>
  <meta name="keywords" content="llvm"/>
  <meta name="date" content="2023-MM-dd"/>

  <style type="text/css">
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<a href="../index.html">トップへ</a>
<p>
  <date>2023-MM-dd</date>
      <tag><a href="../tag.html?tag=llvm">llvm</a></tag>
  </p>

<h1 id="llvm13-マニュアル抜粋">LLVM13 マニュアル抜粋</h1>
<p>c.f <a href="https://releases.llvm.org/13.0.0/docs/LangRef.html">LLVM
Language Reference Manual</a></p>
<h2 id="識別子-identifier">識別子 (Identifier)</h2>
<ul>
<li>局所識別子 : <code>%</code> で始まる．</li>
<li>大域識別子 : <code>@</code> で始まる．
<ul>
<li>LLVM の大域変数はすべて，値を格納する場所へのポインタ．</li>
</ul></li>
</ul>
<h2 id="コメント">コメント</h2>
<ul>
<li><code>;</code> 以降行末まで．</li>
</ul>
<h2 id="module">Module</h2>
<ul>
<li>Module : LLVM の翻訳単位
<ul>
<li>関数 + 大域変数 + 記号表 (シンボルテーブル)</li>
</ul></li>
</ul>
<h2 id="linkage-type">Linkage Type</h2>
<ul>
<li><code>private</code>
<ul>
<li>同一モジュール内からのみアクセス可能．</li>
<li>記号表には載らない．</li>
</ul></li>
<li><code>internal</code>
<ul>
<li>C の <code>static</code> キーワードに対応．</li>
<li>同一モジュール内からのみアクセス可能．</li>
<li><code>STB_LOCAL</code> に載る．</li>
</ul></li>
<li><code>available_externally</code>
<ul>
<li>無視して良い?</li>
</ul></li>
<li><code>linkonce</code>
<ul>
<li>リンク時に名前が衝突したら統合する．</li>
</ul></li>
<li><code>weak</code>
<ul>
<li>C の <code>weak</code> に対応．</li>
<li>多重定義があった際にこの定義を捨てる．</li>
</ul></li>
<li><code>common</code>
<ul>
<li>?</li>
</ul></li>
<li><code>appending</code></li>
<li><code>extern_weak</code></li>
<li><code>linkonce_odr</code></li>
<li><code>weak_odr</code></li>
<li><code>external</code></li>
</ul>
<h2 id="可視性">可視性</h2>
<p>グローバル変数と関数は可視性の指定を持つ．</p>
<ul>
<li><code>default</code>
<ul>
<li>ELF のオブジェクトファイルの場合 :
<ul>
<li>他のモジュールに宣言が見える．</li>
</ul></li>
<li>ELF の共有ライブラリの場合 :
<ul>
<li>宣言は上書き可能．</li>
</ul></li>
</ul></li>
<li><code>hidden</code>
<ul>
<li>他のモジュールがこの変数を直接参照することはできない．</li>
<li>動的シンボルテーブルに載らない．</li>
</ul></li>
<li><code>protected</code>
<ul>
<li>動的シンボルテーブルに載る．</li>
<li>そのサシ先はローカルシンボルである．</li>
<li>すなわち，そのシンボルは他のモジュールで上書きできない．</li>
</ul></li>
</ul>
<h2 id="グローバル変数">グローバル変数</h2>
<ul>
<li>コンパイル時に配置するメモリ領域が決定する．</li>
<li>初期化できる．</li>
<li>配置するセクションを明示できる．</li>
<li>アラインメントを指定できる．</li>
</ul>
<h2 id="型システム">型システム</h2>
<ul>
<li><p>void : <code>void</code></p></li>
<li><p>関数 : <code>&lt;retty&gt; (&lt;param list&gt;)</code></p>
<ul>
<li><code>i32 (i32)</code></li>
<li><code>i32 (i8*, ...)</code></li>
<li><code>{i32, i32} (i32)</code></li>
</ul></li>
<li><p>第一級型 (命令の返り値として取れる型)</p>
<ul>
<li>整数 : <code>iN</code> (<code>N</code> はビット長)</li>
<li>小数 : <code>half</code>, <code>bfloat</code>, <code>float</code>,
…</li>
<li>ポインタ : <code>&lt;type&gt;*</code>
<ul>
<li><code>[4 x i32]*</code> : 配列へのポインタ</li>
<li><code>i32 (i32*) *</code> : 関数ポインタ</li>
<li><code>void*</code> や <code>label*</code> は存在しない．代わりに
<code>i8*</code> を使う．</li>
</ul></li>
<li>ベクタ型 (SIMD 用)</li>
<li>ラベル型</li>
<li>トークン型</li>
<li>メタデータ型</li>
<li>集約型 (aggregate type)
<ul>
<li>array 型 : <code>[40 x i32]</code>,
<code>[3 x [4 x i32]]]</code></li>
<li>struct 型 : <code>{ i32, i32 }</code>,
<code>&lt;{ i8, i32 }&gt;</code>
<ul>
<li><code>&lt;&gt;</code> 囲みは packed.</li>
<li>メモリ内の struct の要素には， <code>getelementptr</code>
でポインタを得て <code>load</code>/<code>store</code> でアクセス</li>
<li>レジスタ内の struct
の要素には，<code>extractvalue</code>/<code>insertvalue</code>
でアクセス</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>target extension type</p></li>
<li><p>vector type</p>
<ul>
<li>SIMD で使う．</li>
</ul></li>
</ul>
<h2 id="定数">定数</h2>
<ul>
<li>Token : <code>none</code> は空のトークン型の値</li>
<li>大域変数，関数のアドレス
<ul>
<li>これらはリンク時に確定する． (大域変数はすべてポインタなので)</li>
</ul></li>
<li>undef</li>
<li>poison</li>
<li>well-defined</li>
<li>address of bb</li>
<li>dso local</li>
<li>constexpr</li>
</ul>
<h2 id="その他の値">その他の値</h2>
<ul>
<li>インラインアセンブリ : よしなに作った値を
<code>call</code>/<code>invoke</code> して使う．</li>
</ul>
<h2 id="メタデータ">メタデータ</h2>
<h2 id="組み込み大域変数">組み込み大域変数</h2>
<h2 id="命令">命令</h2>
<ul>
<li>終端命令
<ul>
<li><code>ret</code>
<ul>
<li><code>ret &lt;type&gt; &lt;value&gt;</code></li>
<li><code>ret void</code></li>
</ul></li>
<li><code>br</code>
<ul>
<li>conditional :
<code>br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</code></li>
<li>unconditional : <code>br label &lt;dest&gt;</code></li>
</ul></li>
<li><code>switch</code>
<ul>
<li><code>switch &lt;intty&gt; &lt;value&gt;, label &lt;defaultdest&gt; [ &lt;intty&gt; &lt;val&gt;, label &lt;dest&gt; ...]</code></li>
</ul></li>
<li><code>indirectbr</code>
<ul>
<li><code>indirectbr &lt;somety&gt;* &lt;address&gt;, [ label &lt;dest1&gt;, label &lt;dest2&gt;, ... ]</code></li>
<li><code>address</code> で指定されたアドレスに飛ぶ．飛び先候補は
<code>destN</code>．</li>
</ul></li>
<li><code>callbr</code>
<ul>
<li>gcc のインラインアセンブリで goto するために使う．</li>
</ul></li>
<li><code>unreachable</code></li>
<li>例外関係
<ul>
<li><code>invoke</code></li>
<li><code>resume</code></li>
<li><code>catchswitch</code></li>
<li><code>catchret</code></li>
<li><code>cleanupret</code></li>
</ul></li>
</ul></li>
<li>単項演算
<ul>
<li><code>fneg</code></li>
</ul></li>
<li>二項演算
<ul>
<li><code>add</code></li>
<li>…</li>
</ul></li>
<li>ベクトル演算 (SIMD)
<ul>
<li>…</li>
</ul></li>
<li>メモリアクセス
<ul>
<li><code>alloca</code>
<ul>
<li><code>&lt;result&gt; = alloca [inalloca] &lt;type&gt; [, &lt;ty&gt; &lt;NumElements&gt;] [, align &lt;alignment&gt;] [, addrspace(&lt;num&gt;)]</code></li>
<li>スタックに領域を確保し，そのアドレスを返す．</li>
</ul></li>
<li><code>load</code></li>
<li><code>store</code></li>
<li><code>fence</code></li>
<li><code>cmpxchg</code></li>
<li><code>atomicrmw</code></li>
<li><code>getelementptr</code>
<ul>
<li><code>&lt;result&gt; = getelementptr &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;{, [inrange] &lt;ty&gt; &lt;idx&gt;}*</code></li>
<li><code>&lt;result&gt; = getelementptr inbounds &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;{, [inrange] &lt;ty&gt; &lt;idx&gt;}*</code></li>
<li><code>&lt;result&gt; = getelementptr &lt;ty&gt;, &lt;ptr vector&gt; &lt;ptrval&gt;, [inrange] &lt;vector index type&gt; &lt;idx&gt;</code></li>
<li>メンバなどのアドレスを取得する．
<ul>
<li>第1引数 : ベースの型</li>
<li>第2引数 : ポインタ (ベースアドレス)</li>
</ul></li>
</ul></li>
</ul></li>
<li>変換
<ul>
<li><code>trunc .. to</code></li>
<li>…</li>
</ul></li>
<li>その他
<ul>
<li><code>icmp</code></li>
<li><code>fcmp</code></li>
<li><code>phi</code></li>
<li><code>select</code></li>
<li><code>freeze</code></li>
<li><code>call</code></li>
<li><code>va_arg</code></li>
<li><code>landingpad</code></li>
<li><code>catchpad</code></li>
<li><code>cleanuppad</code></li>
</ul></li>
<li>組み込み関数
<ul>
<li>可変長引数系</li>
<li>GC 系</li>
<li>コード生成系</li>
<li>標準 C/C++ 系
<ul>
<li><code>llvm.memcpy</code></li>
<li><code>llvm.memcpy.inline</code></li>
<li><code>llvm.memmove</code></li>
<li><code>llvm.memset.*</code></li>
</ul></li>
<li>ループ
<ul>
<li><code>llvm.set.loop.iterations.*</code></li>
<li><code>llvm.start.loop.iterations.*</code></li>
<li><code>llvm.test.set.loop.iterations.*</code></li>
<li><code>llvm.test.start.loop.iterations.*</code></li>
<li><code>llvm.loop.decrement.reg.*</code></li>
<li>`llvm.loop.decrement.*``</li>
</ul></li>
<li>デバッガ用</li>
<li>トランポリン用</li>
<li>その他
<ul>
<li><code>llvm.var.annotation</code></li>
<li><code>llvm.ptr.annotation</code></li>
<li><code>llvm.annotation.*</code></li>
</ul></li>
<li>要素単位原子命令
<ul>
<li><code>llvm.memcpy.element.unordered.atomic</code></li>
<li><code>llvm.memmove.element.unordered.atomic</code></li>
<li><code>llvm.memset.element.unordered.atomic</code></li>
</ul></li>
<li>…</li>
</ul></li>
</ul>
<h1 id="メモ">メモ</h1>
<h2 id="union-の扱い"><code>union</code> の扱い</h2>
<p>一番大きな型の変数として宣言し、使うときによしなにキャストするようだ。</p>
<p>例 :</p>

<figure><pre><code class="c">#include &lt;stdio.h&gt;
union {
  char c;
  double d;
} a;

int main(void) {
  a.d = 10;
  printf(&quot;%d\n&quot;, a.c);
  return 0;
}</code></pre></figure>

<figure><pre><code class="llvm">%union.anon = type { double }

@a = common dso_local global %union.anon zeroinitializer, align 8
@.str = private unnamed_addr constant [4 x i8] c&quot;%d\0A\00&quot;, align 1

; Function Attrs: noinline nounwind optnone uwtable
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  store i32 0, i32* %1, align 4
  store double 1.000000e+01, double* getelementptr inbounds (%union.anon, %union.anon* @a, i32 0, i32 0), align 8
  %2 = load i8, i8* bitcast (%union.anon* @a to i8*), align 8
  %3 = sext i8 %2 to i32
  %4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 %3)
  ret i32 0
}</code></pre></figure>
<h2 id="struct-の扱い"><code>struct</code> の扱い</h2>
<h2 id="定数式">定数式</h2>
<p>定数を別の定数に変換する</p>
<ul>
<li>切り詰め・拡張
<ul>
<li>trunc</li>
<li>zext</li>
<li>sext</li>
<li>fptrunc</li>
<li>fpext</li>
</ul></li>
<li>小数/整数変換
<ul>
<li>fptoui</li>
<li>fptosi</li>
<li>uitofp</li>
<li>sitofp</li>
</ul></li>
<li>ポインタ/整数変換
<ul>
<li>ptrtoint</li>
<li>inttoptr</li>
</ul></li>
<li>その他汎用変換
<ul>
<li>bitcast</li>
<li>addrspacecast</li>
</ul></li>
<li>その他
<ul>
<li>getelementptr</li>
<li>select</li>
<li>icmp</li>
<li>fcmp</li>
<li>extractelement</li>
<li>insertelement</li>
<li>shufflevector</li>
<li>extractvalue</li>
<li>insertvalue</li>
<li>OPCODE (LHS, RHS) : 任意の二項演算を定数に適用</li>
</ul></li>
</ul>
<h2 id="pointer-aliasing-rules">Pointer Aliasing Rules</h2>
<p>ポインタ値を用いてメモリアクセスをする際は、アクセスするメモリ範囲がポインタ値に紐づいていなければならない。
ポインタ値とメモリ範囲の紐づけは以下のルールで行われる :</p>
<ul>
<li>そのポインタ値が基づいているポインタに紐づいている領域に、そのポインタも紐付けられる。</li>
<li>大域変数を指すポインタ値は、大域変数が格納されているメモリ範囲に紐付けられる。</li>
<li>メモリ割り当ての返り値のポインタ値は、割り当てられたメモリ範囲に紐付けられる。</li>
<li>(default address-space 内の) null
ポインタはどこにも紐づけされない。</li>
<li>undef 値はどこにも紐づけされない。</li>
<li>LLVM
の外で定義された関数の返り値のうち、非ゼロの整数定数かポインタ値であるものは、
LLVM 以外の機構で確保されたメモリ範囲に紐づいているかも知れないが、 LLVM
の機構で確保されたメモリ範囲に紐づくことはない。</li>
</ul>
<p><em>基づく (based on)</em>
ポインタ値が別のポインタ値に基づいているというのは次のルールで決まる</p>
<ul>
<li>scalar <code>getelementptr</code>
で得たポインタ値は、<code>getelementptr</code>
に渡したポインタ値に基づいている。</li>
<li>vector <code>getelementptr</code> で得た lane l
のポインタ値は、<code>getelementptr</code> に渡した ポインタのベクタの
lane l にあるポインタ値に基づいている。</li>
<li><code>bitcast</code> の結果の値は、 <code>bitcast</code>
のオペランドに基づいている。</li>
<li><code>inttoptr</code>
で得られたポインタ値は、そのポインタ値の生成に関与した全てのポインタ値に基づいている。</li>
<li>「基づく」関係は推移則がある。</li>
</ul>
<h2 id="getelementptr-の例"><code>getelementptr</code> の例</h2>

<figure><pre><code class="c">struct RT {
  char A;
  int B[10][20];
  char C;
};
struct ST {
  int X;
  double Y;
  struct RT Z;
};

int *foo(struct ST *s) {
  return &amp;s[1].Z.B[5][13];
}</code></pre></figure>

<figure><pre><code class="llvm">%struct.RT = type { i8, [10 x [20 x i32]], i8 }
%struct.ST = type { i32, double, %struct.RT }

define i32* @foo(%struct.ST* %s) nounwind uwtable readnone optsize ssp {
entry:
  %arrayidx = getelementptr inbounds %struct.ST, %struct.ST* %s, i64 1, i32 2, i32 1, i64 5, i64 13
  ret i32* %arrayidx
}</code></pre></figure>
<h2 id="tbaa-メタデータ"><code>tbaa</code> メタデータ</h2>
<ul>
<li>LLVM IR でメモリは型を持っていない。 (!?)</li>
<li>高レベル言語の型システムを表すのには、代わりにメタデータが使われる。</li>
<li>LLVM の TBAA は semantics と representation からなる。</li>
</ul>
<h3 id="semantics">Semantics</h3>
<ul>
<li>TBAA メタデータシステムは struct path TBAA (!=
<code>tbaa.struct</code>) とも呼ばれる。</li>
<li>Type Descriptor と Access Tag からなる。</li>
<li>Type Descriptor
<ul>
<li>scalar type descriptor : 他の型を内包しない型
<ul>
<li>親はスカラ型か TBAA root</li>
<li>親 : より内部へ内部へ潜るイメージ</li>
</ul></li>
<li>struct type descriptor : 他の型ディスクリプタを内包する型</li>
</ul></li>
<li>Access Tag
<ul>
<li>load, store に付けられるメタデータ</li>
<li>base type, access type, offset からなる。
<ul>
<li>base type から offset の位置にある access type
型の値へのメモリアクセスを表す。</li>
</ul></li>
<li>(BaseTy, Offset) の親子関係 :
<ul>
<li>BaseTy がスカラの場合 :
<ul>
<li>Offset が非ゼロの場合は未定義。</li>
<li>ImmediateParent(BaseTy, 0) は (ParentTy, 0)
<ul>
<li>ただし、 BaseTy の親は ParentTy</li>
</ul></li>
</ul></li>
<li>BaseTy が struct の場合:
<ul>
<li>ImmediateParent(BaseTy, Offset) は (NewTy, NewOffset)
<ul>
<li>NewTy : BaseTy の Offset にある型</li>
<li>NewOffset : それに応じて調整したオフセット</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="representation">Representation</h3>
<ul>
<li>TBAA 型階層のルート
<ul>
<li>引数0,1個の MDNode
<ul>
<li>第1引数 : (オプショナル) MDString</li>
</ul></li>
</ul></li>
<li>Scalar type descriptor : 2引数の MDNode。
<ul>
<li>第1引数 : 型名を表す MDString</li>
<li>第2引数 : 親を指す MDNode</li>
<li>第3引数 : (オプショナル) 定数 0 (ConstantInt) 。</li>
</ul></li>
<li>Struct type descriptor
<ul>
<li>奇数個の引数を持つ MDNode</li>
<li>第1引数 : 型名を表す MDString</li>
<li>第2n引数 : 内包する型 (MDNode)</li>
<li>第2n+1引数 : そのオフセット (ConstantInt)</li>
</ul></li>
<li>Access tag
<ul>
<li>引数3,4個の MDNode
<ul>
<li>第1引数 : base type を指す MDNode</li>
<li>第2引数 : access type を指す MDNode</li>
<li>第3引数 : オフセットを指す ConstantInt</li>
<li>第4引数 : (オプショナル) 0 か 1 の ConstantInt
<ul>
<li>1 : メモリアクセスが constant である (pointsToConstantMemory が true
を返す)</li>
<li>0 : そうでない</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="tbaastruct-メタデータ"><code>tbaa.struct</code> メタデータ</h2>
<ul>
<li><code>llvm.memcpy</code> は構造体のコピーに使われる</li>
<li>しかし、厳密にはパディング部分をコピーする必要はない。</li>
<li><code>tbaa.struct</code> は次の情報を持つ :
<ul>
<li>どのメモリサブ領域がパディングか</li>
<li>その構造体の TBAA tag</li>
<li>引数3Nの MDNode
<ul>
<li>N : メンバのオフセット</li>
<li>N+1 : メンバのサイズ</li>
<li>N+2 : メンバの型の tbaa tag</li>
</ul></li>
</ul></li>
</ul>
<h2 id="aliasanalysis">AliasAnalysis</h2>
<ul>
<li>https://releases.llvm.org/13.0.0/docs/AliasAnalysis.html</li>
<li>flow-insensitive</li>
</ul>
<h3 id="aliasanalysis-class">AliasAnalysis class</h3>
<ul>
<li>エイリアス解析のインタフェース</li>
<li><code>enum AliasResult</code> : alias query の結果</li>
<li><code>enum ModRefResult</code> : mod/ref query の結果</li>
</ul>
<p>複数の値を含むクエリにおいて、定数でない値はすべて同じ関数内で定義されていなくてはならない。</p>
<ul>
<li><p>ポインタの表現</p>
<ul>
<li>開始アドレス + サイズ</li>
</ul></li>
<li><p><code>basic-aa</code> pass</p></li>
<li><p><code>alias</code> メソッド</p>
<ul>
<li>2つのメモリオブジェクトがエイリアスかどうかを判定
<ul>
<li>２つのメモリオブジェクトは同じ関数内で定義されている必要あり。</li>
<li>// つまり、 intra-procedural ?</li>
</ul></li>
<li>返り値は MustAlias, PartialAlias, MayAlias, NoAlias のいずれか。
<ul>
<li>NoAlias : 違う場所を指している or
両方のポインタがメモリの読み出しのみに利用される。</li>
<li>MayAlias : 同じオブジェクトを参照しうる</li>
<li>PartialAlias : 参照するオブジェクトが部分的に重複しうる</li>
<li>MustAlias : 同じアドレスを指す (サイズは？)</li>
</ul></li>
</ul></li>
<li><p><code>getModRefInfo</code> メソッド1</p>
<ul>
<li>命令の実行が、メモリ位置の読み取りあるいは編集を行うか否かを得る。
<ul>
<li>// load, store の有無？</li>
<li>保守的な結果を返す</li>
</ul></li>
</ul></li>
<li><p><code>getModRefInfo</code> メソッド2</p>
<ul>
<li>2つのコールサイト (CS1, CS2) を受け取る</li>
<li>CS1 が読む/書くメモリの集合を R1/W1, 同様に R2/W2 と置く。</li>
<li>NoModRef : (W1 ∧ (R2 ∨ W2)) ∨ (W2 ∧ (R1 ∨ W1)) = ∅
<ul>
<li>他方が読み書きするメモリに書き込まない</li>
</ul></li>
<li>Ref : R1 ∧ W2 != ∅
<ul>
<li>CS2 が書いたメモリを CS1 が読む。</li>
</ul></li>
<li>Mod : W1 ∧ (R2 ∨ W2) != ∅
<ul>
<li>CS2 が読み/書きしたメモリを CS1 が読む。</li>
</ul></li>
<li>ModRef : (R1 ∨ W1) ∧ W2 != ∅
<ul>
<li>CS2 が書いたメモリを CS1 が読み書きする。</li>
</ul></li>
</ul></li>
<li><p><code>doesNotAccessMemory</code> メソッド</p>
<ul>
<li>関数がメモリを読み書きしない or constant メモリのみを読むなら真</li>
<li>これが真なら <code>onlyReadsMemory</code> も真。</li>
</ul></li>
<li><p><code>onlyReadsMemory</code> メソッド</p>
<ul>
<li>関数がメモリ読み込みしないなら真。</li>
</ul></li>
</ul>
</body>
</html>
